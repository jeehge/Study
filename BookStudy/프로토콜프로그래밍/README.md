
<hr>

# 읽을 책 

[스위프트4 프로토콜지향 프로그래밍](http://www.yes24.com/Product/Goods/65774164)

<br>

책 읽는 방식 - 나와의 약속 ✍️

첫번째. 가볍게 책을 읽고 텍스트 정리

두번째. 정리한 텍스트를 보고 이해 안되는 부분 정리

<hr>


# [01. 프로토콜의 시작](#프로토콜의-시작)

### [01.01 프로토콜 문법](#프로토콜의-문법)
### [01.02 프로토콜 상속](#프로토콜의-상속)
### [01.03 프로토콜 컴포지션](#프로토콜의-컴포지션)
### [01.04 프로토콜 타입으로 사용](#프로토콜의-타입으로-사용)
### [01.05 프로토콜 다형성](#프로토콜의-다형성)
### [01.06 프로토콜 형 변환](#프로토콜의-형-변환)
### [01.07 연관 타입과 프로토콜](#연관-타입과-프로토콜)
### [01.08 델리게이션](#델리게이션)
### [01.09 프로토콜을 사용해 설계](#프로토콜을-사용해-설계)
### [01.10 스위프트 표준 라이브러리의 프로토콜](#스위프트-표준-라이브러리의-프로토콜)
### [01.11 요약](#요약)

# [02. 타입선택](#타입선택)
  
### [02.01 클래스](#클래스)
### [02.02 구조체](#구조체)
### [02.03 접근제어](#접근제어)
### [02.04 열거형](#열거형)
### [02.05 튜플](#튜플)
### [02.06 프로토콜](#프로토콜)
### [02.07 값 타입과 참조 타입](#값-타입과-참조-타입)
### [02.08 참조 타입만을 위한 재귀적 데이터 타입](#참조-타입만을-위한-상속)
### [02.09 참조 타입만을 위한 상속](#참조-타입만을-위한-상속)
### [02.10 다이내믹 디스패치](#다이내믹-디스패치)
### [02.11 스위프트 내장 타입](#스위프트-내장-타입)
### [02.12 Copy-on-write](#Copy-on-write)
### [02.13 요약](#요약)

# [03. 확장](#확장)

### [03.01 확장 정의](#확장-정의)
### [03.02 프로토콜 확장](#프로토콜-확장)
### [03.03 문장 유효성](#문장-유효성)
### [03.04 스위프트 표준 라이브러리 확장](#스위프트-표준-라이브러리-확장)
### [03.05 Equatable 프로토콜 따르기](#Equatable-프로토콜-따르기)
### [03.06 요약](#요약)

# [04. 제네릭](#제네릭)

### [04.01 제네릭 함수]
### [04.02 제네릭 타입 제약]
### [04.03 제네릭 타입]
### [04.04 연관 타입]
### [04.05 제네릭 서브스크립트]
### [04.06 Copy-on-write]
### [04.07 프로토콜지향 설계 방식에서의 제네릭]
### [04.08 스위프트 표준 라이브러리와 제네릭]
### [04.09 요약]

# [05. 객체지향 프로그래밍](#객체지향-프로그래밍)

### [05.01 객체지향 프로그래밍]
### [05.02 샘플 코드를 위한 요구 사항]
### [05.03 객체지향 프로그래밍 언어로서의 스위프트]
### [05.04 객체지향 설계 방식의 문제점]
### [05.05 요약]

# [06. 프로토콜지향 프로그래밍](#프로토콜지향-프로그래밍)

### [06.01 샘플 코드를 위한 요구 사항]
### [06.02 프로토콜지향 프로그래밍 언어로서의 스위프트]
###  [06.03 프로토콜지향 프로그래밍과 객체지향 프로그래밍 요약]
###  [06.04 객제지향 프로그래밍과 프로토콜지향 프로그래밍의 차이점]
###  [06.05 승자는...]
###  [06.06 요약]

# [07. 스위프트에서 디자인 패턴 적용](#스위프트에서-디자인-패턴-적용)

###  [07.01 디자인 패턴이란?]
###  [07.02 생성 패턴]
###  [07.03 구조 디자인 패턴]
###  [07.04 행동 디자인 패턴]
###  [07.05 요약]

# [08. 사례연구](#사례연구)

###  [08.01 로깅 서비스]
###  [08.02 데이터 접근 계층]
###  [08.03 요약]
###  [08.04 찾아보기]

<hr>

# 프로토콜의 시작

swift 는 최초의 프로토콜지향 프로그래밍 언어이다

프로토콜의 시작에서 다룰 내용은 아래와 같다

- 프로토콜을 사용해 프로퍼티와 기능 요구 사항을 정의하는 방법

- 프로토콜 상속과 컴포지션을 사용하는 방법

- 프로토콜을 타입으로 사용하는 방법

- 다형성

- 프로토콜을 사용해 연관 타입을 사용하는 방법

- 프로토콜을 사용해 델리게이션 패턴을 구현하는 방법

- 프로토콜을 사용해 타입 요구 사항을 설계하는 방법

<br>

### 프로토콜의 문법

프로토콜을 사용해 프로퍼티와 기능 요구 사항을 정의하는 방법 

- 프로토콜 정의
  ```
  protocol MyProtocol {
    // 프로토콜 정의는 여기에 위치
  }
  ```
  프로토콜을 정의하기 위해서는 `protocol` 키워드를 사용
  
  프로토콜을 따르는 구조체 정의 👇
  ```
  struct MyStruct: MyProtocol {
    // 구조체 구현체는 여기에 위치 
  }
  ```
  
  다중 프로토콜을 따를 수 있음
  
  콜론(:)으로 구분해 열거
  
  ```
  struct MyStruct: MyProtocol, AnotherProtocol, ThirdProtocol {
    // 구조체 구현체는 여기에 위치
  }
  ```
  
- 프로퍼티 요구사항
  
  프로토콜은 자세한 구현체는 프로토콜을 따르는 타입에 맞기기 때문에 프로퍼티가 저장 프로퍼티(store property)나 연산 프로퍼티(computed property)가 돼야 한다는 것을 이야기하지 않음
  
  프로토콜에서 프로퍼티를 정의할 때, get과 set 키워드를 사용해 프로퍼티가 읽기 전용 프로퍼티인지 읽기 쓰기 프로퍼티인지를 반드시 명시해줘야 함
  
  프로토콜에 프로퍼티 정의
   ```
  protocol FullName {
    var firstName: String { get set } // 읽기 쓰기 프로퍼티 
    var lastName: String { get set }
    var readOnly: String { get } // 읽기 전용 프로퍼티
    static var typeProperty: String { get } // static 키워드를 사용하면 정적 프로퍼티 정의도 사용 가능
  }
  ```
  
- 메소드 요구사항
  
  중괄호와 메소드 몸체가 없다는 점을 제외하고는 클래스와 구조체에서 정의했던 것과 같음
  
  static 키워드를 사용함으로써 인스턴스 메소드나 타입 메소드가 되도록 정의 가능
  
  프로토콜에 메소드를 정의할 때에는 메소드 매개변수에 기본 값을 추가하는 것이 `허용되지 않음`
  
  메소드 정의
  ```
  protocol FullName {
    var firstName: String { get set }
    var lastName: String { get set }
    func getFullName() -> String
  }
  ```
  
  구조체와 같은 값 타입의 경우 메소드가 메소드 자신이 속해 있는 인스턴스를 변경하고자 의도하는 경우에는 반드시 메소드 정의부 앞부분에 `mutating 키워드`를 추가해줘야 함
  
  메소드가 내용을 변경할 수 있게 메소드 요구 사항을 정의한 경우 참조(클래스) 타입에 해당 프로토콜을 적용할 때에는 메소드에 mutating 키워드를 입력할 필요 없음
  
  `mutating 키워드는 오직 값(구조체 또는 열거형) 타입에만 사용` 
  
  
- 선택 가능한 요구사항
  
  메소드나 프로퍼티의 구현을 요구하지 않을 때! 프로토콜 앞부분에 @objc 사용
  
  오직 클래스만 @objc 속성을 사용하는 프로토콜을 채용할 수 있음
  
  `optional 키워드`를 사용하면 프로퍼티나 메소드가 선택 가능하다는 것으로 표시 가능
  
  ```
  @objc protocol Phone {
    var phoneNumber: String { get set }
    @objc optional var emailAddress: String { get set }
    func dialNumber()
    @objc optional func getEmail()
  }
  ```

- 프로토콜 상속
  
  프로토콜 상속 문법
  ```
  protocol ProtocolThree: ProtocolOne, ProtocolTwo {
    // 요구 사항은 여기에 위치
  }
  ```
  스위프트에서 프로토콜은 한개 이상 상속 가능하며, 이 점 제외하면 클래스 상속을 위한 문법과 유사
  
  


- 프로토콜 

### 프로토콜의 상속


### 프로토콜의 컴포지션
### 프로토콜의 타입으로 사용

프로토콜을 타입으로 사용하는 방법


### 프로토콜의 다형성
### 프로토콜의 형 변환
### 연관 타입과 프로토콜

프로토콜을 사용해 연관 타입을 사용하는 방법


### 델리게이션

프로토콜을 사용해 델리게이션 패턴을 구현하는 방법


### 프로토콜을 사용해 설계

프로토콜을 사용해 타입 요구 사항을 설계하는 방법


### 스위프트 표준 라이브러리의 프로토콜
### 요약



  
  






# 타입선택
